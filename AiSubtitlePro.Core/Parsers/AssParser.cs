using AiSubtitlePro.Core.Models;
using AiSubtitlePro.Core.Models.Enums;
using System.Drawing;
using System.Text;
using System.Text.RegularExpressions;

namespace AiSubtitlePro.Core.Parsers;

/// <summary>
/// Parser for ASS (Advanced SubStation Alpha) and SSA (SubStation Alpha) subtitle formats.
/// Fully compliant with the ASS v4+ specification.
/// </summary>
public class AssParser : ISubtitleParser
{
    public SubtitleFormat Format => SubtitleFormat.Ass;
    
    public IReadOnlyList<string> SupportedExtensions => new[] { ".ass", ".ssa" };

    private static readonly Regex TimeRegex = new(@"(\d+):(\d{2}):(\d{2})\.(\d{2})", RegexOptions.Compiled);

    public SubtitleDocument Parse(string content)
    {
        var document = new SubtitleDocument { Format = SubtitleFormat.Ass };
        var lines = content.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
        
        string currentSection = "";
        string[]? styleFormat = null;
        string[]? eventFormat = null;

        foreach (var line in lines)
        {
            var trimmedLine = line.Trim();
            
            if (string.IsNullOrEmpty(trimmedLine) || trimmedLine.StartsWith(";"))
                continue;

            // Section headers
            if (trimmedLine.StartsWith("[") && trimmedLine.EndsWith("]"))
            {
                currentSection = trimmedLine.ToLowerInvariant();
                continue;
            }

            switch (currentSection)
            {
                case "[script info]":
                    ParseScriptInfo(trimmedLine, document.ScriptInfo);
                    break;

                case "[v4+ styles]":
                case "[v4 styles]":
                    if (trimmedLine.StartsWith("Format:", StringComparison.OrdinalIgnoreCase))
                    {
                        styleFormat = ParseFormat(trimmedLine);
                    }
                    else if (trimmedLine.StartsWith("Style:", StringComparison.OrdinalIgnoreCase) && styleFormat != null)
                    {
                        var style = ParseStyle(trimmedLine, styleFormat);
                        if (style != null)
                        {
                            // Remove default if this is the first style added
                            if (document.Styles.Count == 1 && document.Styles[0].Name == "Default")
                                document.Styles.Clear();
                            document.Styles.Add(style);
                        }
                    }
                    break;

                case "[events]":
                    if (trimmedLine.StartsWith("Format:", StringComparison.OrdinalIgnoreCase))
                    {
                        eventFormat = ParseFormat(trimmedLine);
                    }
                    else if ((trimmedLine.StartsWith("Dialogue:", StringComparison.OrdinalIgnoreCase) ||
                              trimmedLine.StartsWith("Comment:", StringComparison.OrdinalIgnoreCase)) && eventFormat != null)
                    {
                        var subtitleLine = ParseDialogue(trimmedLine, eventFormat);
                        if (subtitleLine != null)
                        {
                            subtitleLine.Index = document.Lines.Count + 1;
                            document.Lines.Add(subtitleLine);
                        }
                    }
                    break;
            }
        }

        return document;
    }

    public async Task<SubtitleDocument> ParseFileAsync(string filePath)
    {
        var content = await File.ReadAllTextAsync(filePath, Encoding.UTF8);
        var document = Parse(content);
        document.FilePath = filePath;
        
        // Detect format from extension
        var ext = Path.GetExtension(filePath).ToLowerInvariant();
        document.Format = ext == ".ssa" ? SubtitleFormat.Ssa : SubtitleFormat.Ass;
        
        return document;
    }

    public string Serialize(SubtitleDocument document)
    {
        var sb = new StringBuilder();

        // Script Info
        sb.AppendLine("[Script Info]");
        sb.AppendLine("; Script generated by AiSubtitlePro");
        sb.AppendLine($"Title: {document.ScriptInfo.Title}");
        sb.AppendLine($"ScriptType: {document.ScriptInfo.ScriptType}");
        sb.AppendLine($"WrapStyle: {document.ScriptInfo.WrapStyle}");
        sb.AppendLine($"ScaledBorderAndShadow: {(document.ScriptInfo.ScaledBorderAndShadow ? "yes" : "no")}");
        sb.AppendLine($"PlayResX: {document.ScriptInfo.PlayResX}");
        sb.AppendLine($"PlayResY: {document.ScriptInfo.PlayResY}");
        
        if (!string.IsNullOrEmpty(document.ScriptInfo.YCbCrMatrix) && document.ScriptInfo.YCbCrMatrix != "None")
            sb.AppendLine($"YCbCr Matrix: {document.ScriptInfo.YCbCrMatrix}");

        sb.AppendLine();

        // Styles
        sb.AppendLine("[V4+ Styles]");
        sb.AppendLine("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding");
        
        foreach (var style in document.Styles)
        {
            sb.AppendLine(SerializeStyle(style));
        }

        sb.AppendLine();

        // Events
        sb.AppendLine("[Events]");
        sb.AppendLine("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");
        
        foreach (var line in document.Lines)
        {
            sb.AppendLine(SerializeDialogue(line));
        }

        return sb.ToString();
    }

    public async Task SaveFileAsync(SubtitleDocument document, string filePath)
    {
        var content = Serialize(document);
        await File.WriteAllTextAsync(filePath, content, new UTF8Encoding(true));
        document.FilePath = filePath;
        document.IsDirty = false;
    }

    #region Parsing Helpers

    private static string[] ParseFormat(string line)
    {
        var colonIndex = line.IndexOf(':');
        if (colonIndex < 0) return Array.Empty<string>();
        
        return line[(colonIndex + 1)..]
            .Split(',')
            .Select(s => s.Trim().ToLowerInvariant())
            .ToArray();
    }

    private static void ParseScriptInfo(string line, ScriptInfo info)
    {
        var colonIndex = line.IndexOf(':');
        if (colonIndex < 0) return;

        var key = line[..colonIndex].Trim().ToLowerInvariant();
        var value = line[(colonIndex + 1)..].Trim();

        switch (key)
        {
            case "title": info.Title = value; break;
            case "original script": info.OriginalScript = value; break;
            case "original translation": info.OriginalTranslation = value; break;
            case "original editing": info.OriginalEditing = value; break;
            case "original timing": info.OriginalTiming = value; break;
            case "synch point": info.SynchPoint = value; break;
            case "script updated by": info.ScriptUpdatedBy = value; break;
            case "update details": info.UpdateDetails = value; break;
            case "scripttype": info.ScriptType = value; break;
            case "collisions": info.Collisions = value; break;
            case "playdepth": double.TryParse(value, out var depth); info.PlayDepth = depth; break;
            case "playresx": int.TryParse(value, out var resX); info.PlayResX = resX; break;
            case "playresy": int.TryParse(value, out var resY); info.PlayResY = resY; break;
            case "timer": double.TryParse(value, out var timer); info.Timer = timer; break;
            case "wrapstyle": int.TryParse(value, out var wrap); info.WrapStyle = wrap; break;
            case "scaledborderandshadow": info.ScaledBorderAndShadow = value.ToLowerInvariant() == "yes"; break;
            case "ycbcr matrix": info.YCbCrMatrix = value; break;
            default: info.CustomProperties[key] = value; break;
        }
    }

    private static SubtitleStyle? ParseStyle(string line, string[] format)
    {
        var colonIndex = line.IndexOf(':');
        if (colonIndex < 0) return null;

        var parts = SplitStyleLine(line[(colonIndex + 1)..]);
        if (parts.Length < format.Length) return null;

        var style = new SubtitleStyle();

        for (int i = 0; i < format.Length; i++)
        {
            var value = parts[i].Trim();
            switch (format[i])
            {
                case "name": style.Name = value; break;
                case "fontname": style.FontName = value; break;
                case "fontsize": double.TryParse(value, out var size); style.FontSize = size; break;
                case "primarycolour": style.PrimaryColor = SubtitleStyle.AssToColor(value); break;
                case "secondarycolour": style.SecondaryColor = SubtitleStyle.AssToColor(value); break;
                case "outlinecolour": style.OutlineColor = SubtitleStyle.AssToColor(value); break;
                case "backcolour": style.BackColor = SubtitleStyle.AssToColor(value); break;
                case "bold": style.Bold = value == "-1" || value == "1"; break;
                case "italic": style.Italic = value == "-1" || value == "1"; break;
                case "underline": style.Underline = value == "-1" || value == "1"; break;
                case "strikeout": style.StrikeOut = value == "-1" || value == "1"; break;
                case "scalex": double.TryParse(value, out var sx); style.ScaleX = sx; break;
                case "scaley": double.TryParse(value, out var sy); style.ScaleY = sy; break;
                case "spacing": double.TryParse(value, out var spacing); style.Spacing = spacing; break;
                case "angle": double.TryParse(value, out var angle); style.Angle = angle; break;
                case "borderstyle": int.TryParse(value, out var bs); style.BorderStyle = bs; break;
                case "outline": double.TryParse(value, out var outline); style.Outline = outline; break;
                case "shadow": double.TryParse(value, out var shadow); style.Shadow = shadow; break;
                case "alignment": int.TryParse(value, out var align); style.Alignment = align; break;
                case "marginl": int.TryParse(value, out var ml); style.MarginL = ml; break;
                case "marginr": int.TryParse(value, out var mr); style.MarginR = mr; break;
                case "marginv": int.TryParse(value, out var mv); style.MarginV = mv; break;
                case "encoding": int.TryParse(value, out var enc); style.Encoding = enc; break;
            }
        }

        return style;
    }

    private static SubtitleLine? ParseDialogue(string line, string[] format)
    {
        var isComment = line.StartsWith("Comment:", StringComparison.OrdinalIgnoreCase);
        var colonIndex = line.IndexOf(':');
        if (colonIndex < 0) return null;

        var parts = SplitDialogueLine(line[(colonIndex + 1)..], format.Length);
        if (parts.Length < format.Length) return null;

        var subtitle = new SubtitleLine
        {
            Type = isComment ? DialogueType.Comment : DialogueType.Dialogue
        };

        for (int i = 0; i < format.Length; i++)
        {
            var value = parts[i].Trim();
            switch (format[i])
            {
                case "layer": int.TryParse(value, out var layer); subtitle.Layer = layer; break;
                case "start": subtitle.Start = ParseTime(value); break;
                case "end": subtitle.End = ParseTime(value); break;
                case "style": subtitle.StyleName = value; break;
                case "name": subtitle.Actor = value; break;
                case "marginl": int.TryParse(value, out var ml); subtitle.MarginL = ml; break;
                case "marginr": int.TryParse(value, out var mr); subtitle.MarginR = mr; break;
                case "marginv": int.TryParse(value, out var mv); subtitle.MarginV = mv; break;
                case "effect": subtitle.Effect = value; break;
                case "text": subtitle.Text = value; break;
            }
        }

        return subtitle;
    }

    private static TimeSpan ParseTime(string time)
    {
        var match = TimeRegex.Match(time);
        if (!match.Success) return TimeSpan.Zero;

        var hours = int.Parse(match.Groups[1].Value);
        var minutes = int.Parse(match.Groups[2].Value);
        var seconds = int.Parse(match.Groups[3].Value);
        var centiseconds = int.Parse(match.Groups[4].Value);

        return new TimeSpan(0, hours, minutes, seconds, centiseconds * 10);
    }

    private static string[] SplitStyleLine(string line)
    {
        return line.Split(',').Select(s => s.Trim()).ToArray();
    }

    private static string[] SplitDialogueLine(string line, int expectedParts)
    {
        // Split only up to expectedParts-1 commas (text field can contain commas)
        var parts = new List<string>();
        var currentPart = new StringBuilder();
        var commaCount = 0;
        
        foreach (var c in line)
        {
            if (c == ',' && commaCount < expectedParts - 1)
            {
                parts.Add(currentPart.ToString().Trim());
                currentPart.Clear();
                commaCount++;
            }
            else
            {
                currentPart.Append(c);
            }
        }
        
        parts.Add(currentPart.ToString().Trim());
        return parts.ToArray();
    }

    #endregion

    #region Serialization Helpers

    private static string SerializeStyle(SubtitleStyle style)
    {
        return $"Style: {style.Name},{style.FontName},{style.FontSize}," +
               $"{SubtitleStyle.ColorToAss(style.PrimaryColor)}," +
               $"{SubtitleStyle.ColorToAss(style.SecondaryColor)}," +
               $"{SubtitleStyle.ColorToAss(style.OutlineColor)}," +
               $"{SubtitleStyle.ColorToAss(style.BackColor)}," +
               $"{(style.Bold ? "-1" : "0")},{(style.Italic ? "-1" : "0")}," +
               $"{(style.Underline ? "-1" : "0")},{(style.StrikeOut ? "-1" : "0")}," +
               $"{style.ScaleX},{style.ScaleY},{style.Spacing},{style.Angle}," +
               $"{style.BorderStyle},{style.Outline},{style.Shadow},{style.Alignment}," +
               $"{style.MarginL},{style.MarginR},{style.MarginV},{style.Encoding}";
    }

    private static string SerializeDialogue(SubtitleLine line)
    {
        var prefix = line.Type == DialogueType.Comment ? "Comment" : "Dialogue";
        return $"{prefix}: {line.Layer},{FormatTime(line.Start)},{FormatTime(line.End)}," +
               $"{line.StyleName},{line.Actor},{line.MarginL},{line.MarginR},{line.MarginV}," +
               $"{line.Effect},{line.Text}";
    }

    private static string FormatTime(TimeSpan time)
    {
        return $"{(int)time.TotalHours}:{time.Minutes:D2}:{time.Seconds:D2}.{time.Milliseconds / 10:D2}";
    }

    #endregion
}
